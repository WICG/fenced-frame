# Fenced frame use cases



## **Summary**

This document summarizes the various use cases for [fenced frames](https://github.com/shivanigithub/fenced-frame). Each API that uses fenced frames specifies its behavior by generating appropriate [fenced frame configs](https://github.com/shivanigithub/fenced-frame/blob/master/explainer/fenced_frame_config.md).


## **Characteristics of the different use cases**



*   All use cases are similar such that they are isolated from the embedded context via any JS window references, script access, storage access, resizing of the fenced frame, messaging APIs etc.
*   Every use case of fenced frame is different in how its privacy guarantees are preserved and would need a separate launch/review process. The first phase and the associated review process of fenced frames will focus only on its use by FLEDGE, sharedStorage, and the default `FencedFrameConfig()` constructor(s).
*   Each use case’s source url privacy characteristics are different E.g. the “opaque-ads” use case allows providing a config-bound opaque src by the embedder which contains cross-site data e.g. interest groups, the “read-only” use case has src that is known to the embedder and does not need to be mitigated against link decoration. A future “unpartitioned-storage” use case will need the src to be mitigated against link decoration.
*   One of the questions we are trying to answer from an API perspective is how to represent these different use cases of fenced frames. Should they be separate elements, all inheriting the base Fenced Frame element; or should they be the same element where you can set an attribute to load configs generated by different APIs; or a hybrid between these two approaches? In phase 1, for simplicity, we are going with it as an attribute and then if need be and based on TAG/standards discussions, we can pivot to create separate elements.


## **Opaque-ads**

This use case is for rendering ads whose url is opaque to the embedding context. The two consumers of this use case are [FLEDGE](https://github.com/WICG/turtledove/blob/main/FLEDGE.md) and [SharedStorage](https://github.com/pythagoraskitty/shared-storage#simple-example-consistent-ab-experiments-across-sites). 



*   **Use case: “opaque-ads”**
*   **Config:**
     *   Generated by FLEDGE (`navigator.runAdAuction()`) or SharedStorage (`window.sharedStorage.selectURL`).
     *   The url mapped by the config can only be an https, localhost, about:blank.
     *   Note that for this use case, the interesting part is that the source is opaque to the publisher and that is what is discussed in the information flow section below.
     
*   **Example** usage from FLEDGE:
    ```js
    navigator.runAdAuction(myAuctionConfig).then((auctionWinnerConfig) => {
      // auctionWinnerConfig value e.g.
      // FencedFrameConfig {
      //   src: opaque
      //   containerWidth: 100,
      //   containerHeight: 200,
      //   contentWidth: opaque,
      //   contentHeight: opaque,
      //   ...
      // }
      var adFrame = document.createElement('fencedframe');
      adFrame.config = auctionWinnerConfig;
    });
    ```

*   **Information flow and privacy model:**
    *   Src is always guaranteed to be opaque to the embedding context via the config mechanism described above. 
    *   The API that generates the config will enforce that the URL and any other information passed to the fenced frame are k-anonymous. Resizing of the fenced frame by the embedder will also be restricted in the sense that the document loaded in the fenced frame will be scaled for the new size but will not be able to access the current size.
    * The network access being unrestricted is an ongoing technical challenge due to the issue of network timing side channel (described in the explainer [here](https://github.com/WICG/fenced-frame/blob/master/explainer/network_side_channel.md)) and we are considering what a long-term solution for this would look like in fenced frames. For the opaque-ads use case, the considerations are either 1) denying any network access (e.g., loaded via navigable web bundles) or 2) network access only allowed to some trusted caching service that promises to only log aggregate data.    
    *   Like all use cases, the fenced frame is isolated from the embedded context via any JS window references, script access, storage access, messaging APIs etc. The fenced frame does not know the embedding site’s origin or etld+1.
    *   The fenced frame is allowed to create a popup (with noopener) or navigate the top-level page on user activation as described [here](https://github.com/WICG/fenced-frame/blob/master/explainer/integration_with_web_platform.md#top-level-navigation). (This is an ads requirement)
*   **Cross-site data**: Interest groups in Fledge, the cross-site data used to choose the one-of-N URLs for shared storage. 
*   **Reporting**: Reporting for ads would eventually be done using aggregate reporting but for easier adoption there is event-level reporting that will be allowed. Events happening inside the fenced frames will be joined with the data from the FLEDGE/SharedStorage worklet and sent as a beacon. This is detailed [here](https://github.com/WICG/turtledove/blob/main/Fenced_Frames_Ads_Reporting.md)   


## **Default**

This use case is the fenced frames with no special restrictions on the src and no cross-site data inside the fenced frame. It is useful to test fenced frames and can be used for a scenario where the fenced frame itself does not get any special cross-site data but the use case can benefit from the isolation characteristics of a fenced frame.



*   **Use case: “default”**
*   **Config:** Generated by the `FencedFrameConfig(url)` WebIDL constructor. The url must be [Potentially trustworthy](https://w3c.github.io/webappsec-secure-contexts/#potentially-trustworthy-url) url but has no restrictions on its contents
*   **Information flow and privacy model:**
    *   Since there is no unpartitioned/cross-site data available to the fenced frame, it is not able to do any cross-site data joining.
    *   Like all use cases, the fenced frame is isolated from the embedded context via any JS window references, script access, storage access, messaging APIs etc. The fenced frame does not know the embedding site’s origin or etld+1.

To begin experimenting with fenced frames in default mode, enable the following experiments in `chrome://flags`:
* Privacy Sandbox Ads APIs (chrome://flags/#privacy-sandbox-ads-apis)
* Enable the \`FencedFrameConfig\` constructor. (chrome://flags/#enable-fenced-frames-developer-mode)

After relaunching Chrome, a fenced frame can be added to a page with the following code:
```
const frame = document.createElement("fencedframe");
const config = new FencedFrameConfig("https://example.com/");
frame.config = config;
document.body.append(frame);
```

## **Read-only**

This use case is for rendering personalized information in a fenced frame at the same time ensuring that the unpartitioned data accessed by the fenced frame cannot be exfiltrated, by disallowing network and any write access to storage . The two consumers of this use case are [3rd party payment service provider(PSP)'s customized payment buttons](https://github.com/shivanigithub/fenced-frame/issues/15) and possibly a version of [FedCM](https://github.com/fedidcg/FedCM) (the latter is under discussion). 



*   **Use case: “read-only”**
*   **Config:** Generated by some API like `ReadOnlyFencedFrameConfig(url)`. url can only be an https, localhost or about:blank. Is able to carry 1p data from the embedding context to the fenced frame. This is not however an issue as described in the next section. 
*   **Information flow and privacy model:**
    *   The ‘src’ url can carry user id in the embedding page. Up until the fenced frame has completed navigation, there is an unrestricted network. That is fine because there isn’t any unpartitioned data available to the fenced frame till that point.
    *   The fenced frame is able to request access to read-only cookies after navigation is complete. At that point the network will be disallowed so that there is no exfiltration of joined data across sites via either the network or persistent storage. Other partitioned state like storage, service workers, network and http cache will continue to stay partitioned.
*   **Top-level site’s etld+1**: This is required in the initial navigation request so that the PSP/FedCM servers can determine if this is a trusted top-level site that they are allowed to work with.
    *   This is fine because it does not exfiltrate any new information that the embedder itself could not have sent to the payment service provider's server.
*   **Cross-site data**: Read only access to unpartitioned cookies after navigation is complete (document and subresources have loaded) and network is then restricted.


## **Unpartitioned-storage**

This use case is for authenticated embeds e.g. embedded videos, comments etc. 



*   **Use case: “unpartitioned-storage”**
*   **Config:** Generated by some API like `UnpartitionedStorageFencedFrameConfig(url)`. The specified src url should be mitigated against link decoration. (TODO: design) 
*   **Top-level site’s url**: This may be granted on user activation and permission prompt. (TODO: design)
*   **Information flow and privacy model:**
    *   User id from the embedding site is not allowed because of the source url being mitigated against link decoration.
    *   The fenced frame gets access to unpartitioned storage + top-level url (also mitigated against link decoration) on user activation and permission prompt.
*   **Cross-site data:** Gates unpartitioned storage access on user activation + permission prompt.
