<pre class="metadata">
Title: Fenced frame
Shortname: fenced-frame
Repository: WICG/fenced-frame
Inline Github Issues: true
Group: WICG
Status: CG-DRAFT
Level: 1
URL: https://wicg.github.io/fenced-frame/
Boilerplate: omit conformance, omit feedback-header
Editor: Dominic Farolino, Google https://www.google.com/, domfarolino@gmail.com, https://domfarolino.com
Abstract: The fenced frame enforces a boundary between the embedding page and the cross-site embedded document such that user data visible to the two sites is not able to be joined together.
!Participate: <a href="https://github.com/WICG/fenced-frame">GitHub WICG/fenced-frame</a> (<a href="https://github.com/WICG/fenced-frame/issues/new">new issue</a>, <a href="https://github.com/WICG/fenced-frame/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/fenced-frame/commits/main/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
Assume Explicit For: yes
WPT Display: open
</pre>

<pre class="link-defaults">
</pre>
<pre class="anchors">
urlPrefix: https://www.ietf.org/rfc/rfc4122.txt
  type: dfn; text: urn uuid

spec: prerendering-revamped; urlPrefix: https://wicg.github.io/nav-speculation/prerendering.html
  type: dfn
    for: navigable
      text: loading mode; url: #navigable-loading-mode

spec: fetch; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: queue a cross-origin embedder policy CORP violation report; url: queue-a-cross-origin-embedder-policy-corp-violation-report
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
  type: dfn
    urlPrefix: browsers.html
      text: check a navigation response's adherence to its embedder policy; url: check-a-navigation-response's-adherence-to-its-embedder-policy
      text: queue a cross-origin embedder policy inheritance violation; url: queue-a-cross-origin-embedder-policy-inheritance-violation
    urlPrefix: dom.html
      text: categories; url: concept-element-categories
      text: contexts in which this element can be used; url: concept-element-contexts
      text: embedded content; url: embedded-content-category
      text: content model; url: concept-element-content-model
      text: nothing; url: concept-content-nothing
      text: content attributes; url: concept-element-attributes
      text: global attributes; url: global-attributes
      text: dom interface; url: concept-element-dom
      text: accessibility considerations; url: concept-element-accessibility-considerations
      text: represents; url: represents
    urlPrefix: common-dom-interfaces.html
      text: reflect; url: reflect
    urlPrefix: embedder-content-other.html
      text: width; url: attr-dim-width
      text: height; url: attr-dim-height
    urlPrefix: document-sequences.html
      text: browsing context group; url: browsing-context-group
      text: browsing context group set; url: browsing-context-group-set
      text: creator base url; url: creator-base-url
      text: create a new browsing context and document; url: creating-a-new-browsing-context
      text: create a new browsing context group and document; url: creating-a-new-browsing-context-group
      text: initialize the navigable; url: initialize-the-navigable
      text: node navigable; url: node-navigable
      text: system visibility state; url: system-visibility-state
      for: navigable
        text: active session history entry; url: nav-active-history-entry
        text: current session history entry; url: nav-current-history-entry
        text: parent; url: nav-parent
      for: traversable navigable
        text: session history entries; url: tn-session-history-entries
      for: browsing context group
        text: cross-origin isolation mode; url: bcg-cross-origin-isolation
      for: cross-origin isolation mode
        text: none; url:cross-origin-isolation-none
    urlPrefix: document-lifecycle.html
      text: create and initialize a Document object; url: initialise-the-document-object
    urlPrefix: browsing-the-web.html
      text: create navigation params by fetching; url: create-navigation-params-by-fetching
      text: document state; url: she-document-state
      text: historyHandling; url: navigation-hh
      text: referrerPolicy; url: navigation-referrer-policy
      text: attempt to populate the history entry's document; url: attempt-to-populate-the-history-entry's-document
      for: navigation params
        text: response; url: navigation-params-response
        text: navigable; url: navigation-params-navigable
        text: origin; url: navigation-params-origin
      for: history handling behavior
        text: replace; url: hh-replace
      for: document state
        text: document; url: document-state-document
    urlPrefix: interaction.html
      text: activation notification; url: activation-notification
      text: consume user activation; url: consume-user-activation
      text: activation; url: activation
      text: click focusable; url: click-focusable
      text: focusable area; url: focusable-area
      text: sequential focus navigation; url: sequential-focus-navigation
      text: focus; url: dom-window-focus
      text: focus chain; url: focus-chain
      text: focus update steps; url: focus-update-steps
      text: focused; url: focused
      text: gain focus; url: gains-focus
      text: DOM anchor; url: dom-anchor
      text: get the focusable area; url: get-the-focusable-area
      text: currently focused area of a top-level traversable; url: currently-focused-area-of-a-top-level-traversable
      text: focused area; url: focused-area-of-the-document
      text: sequential navigation search algorithm; url: sequential-navigation-search-algorithm
    urlPefix: infrastructure.html
      text: immediately; url: immediately
    urlPrefix: nav-history-apis.html
      for: Window
        text: navigable; url: window-navigable
    urlPrefix: webappapis.html
      for: environment
        text: target browsing context; url: concept-environment-target-browsing-context
    urlPrefix: document-sequences.html
      for: browsing context
        text: active document; url: active-document
spec: fetch; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: queue a cross-origin embedder policy CORP violation report; url: queue-a-cross-origin-embedder-policy-corp-violation-report
    text: should request be blocked due to a bad port; url: block-bad-port
spec: mixed-content; urlPrefix: https://w3c.github.io/webappsec-mixed-content/
  type: dfn
    text: should fetching request be blocked as mixed content; url: should-block-fetch
spec: CSP; urlPrefix: https://w3c.github.io/webappsec-csp/
  type: dfn
    urlPrefix: interactive-elements.html
      text: accesskey attribute command; url: using-the-accesskey-attribute-to-define-a-command-on-other-elements
      text: previously focused element; url: previously-focused-element
    urlPrefix: popover.html
      text: hide popover algorithm; url: hide-popover-algorithm
    urlPrefix: form-control-infrastructure.html
      text: interactively validate the constraints; url: interactively-validate-the-constraints
    urlPrefix: custom-elements.html
      text: face validation anchor; url: face-validation-anchor
    urlPrefix: webappapis.html
      text: fire a click event; url: fire-a-click-event
spec: RFC8941; urlPrefix: https://www.rfc-editor.org/rfc/rfc8941.html
  type: dfn
    text: structured header; url: #section-1
    for: structured header
      text: token; url: name-tokens
spec: permissions-policy; urlPrefix: https://w3c.github.io/webappsec-permissions-policy
  type: dfn
    text: Create a Permissions Policy for a navigable; url: algo-create-for-navigable
    text: Create a Permissions Policy for a navigable from response; url: algo-create-from-response
    text: Define an inherited policy for feature in container at origin; url: define-inherited-policy-in-container
    text: default allowlist; url: policy-controlled-feature-default-allowlist
    text: ASCII-serialized policy directive; url: serialized-policy-directive
    text: inherited policy; url: inherited-policy
    text: serialized permissions policy; url: serialized-permissions-policy
    for: permissions
      text: matches; url: matches
      text: permissions policy; url: permissions-policy
spec: CSP; urlPrefix: https://w3c.github.io/webappsec-csp/
  type: dfn
    text: directive value; url: directive-value
    text: frame-src pre-request check; url: frame-src-pre-request
    text: frame-src post-request check; url: frame-src-post-request
    text: Get the effective directive for request; url: effective-directive-for-a-request
spec: CSPEE; urlPrefix: https://w3c.github.io/webappsec-cspee/
  type: dfn
    text: Is response to request blocked by context's required CSP?; url: process-response
    text: required csp; url: browsing-context-required-csp
</pre>

<style>
/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
  padding: .5em;
  border: thin solid #ddd; border-radius: .5em;
  margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
  margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
  margin-bottom: 0;
}
[data-algorithm] [data-algorithm] {
  margin: 1em 0;
}

.selected-text-file-an-issue {
  position: fixed;
  bottom: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.8);
  font-size: smaller;
  padding: 4px 10px;
  z-index: 4;
}

dfn var {
  font-style: italic;
}

table {
  margin: 1em 0;
}

/* WHATWG-style <hr>s, instead of WICG-style. Specific selector is necessary to override WICG styles. */
:not(.head) > :not(.head) + hr {
  display: block;
  background: none;
  border: none;
  padding: 0;
  margin: 3em 0;
  height: auto;
}
:not(.head) > :not(.head) + hr::before {
  content: none;
}

/* WHATWG-style element definition class */
.element {
  background: #EEFFEE;
}
dt {
  margin-top: 12px;
  color: black;
}
dl, dd {
  padding-left: .5em;
}

/* domintro from https://resources.whatwg.org/standard.css */
.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

.domintro dt, .domintro dt * {
  color: black;
  font-size: inherit;
}
.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
.domintro dd p {
  margin: 0.5em 0;
}
.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}

/* .XXX from https://resources.whatwg.org/standard.css */
.XXX {
  color: #D50606;
  background: white;
  border: solid #D50606;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id=the-fencedframe-element>The <dfn element export>fencedframe</dfn> element</h2>

<dl class="element">
 <dt>[=Categories=]:</dt>
 <dd>[=Flow content=].</dd>
 <dd>[=Phrasing content=].</dd>
 <dd>[=Embedded content=].</dd>
 <dd>[=Interactive content=].</dd>
 <dd>[=Palpable content=].</dd>
 <dt>[=Contexts in which this element can be used=]:</dt>
 <dd>Where [=embedded content=] is expected.</dd>
 <dt>[=Content model=]:</dt>
 <dd>[=Nothing=].</dd>
 <dt>[=Content attributes=]:</dt>
 <dd>[=Global attributes=]</dd>
 <dd><code>[=width=]</code> — Horizontal dimension</dd>
 <dd><code>[=height=]</code> — Vertical dimension</dd>
 <dd><code><{fencedframe/allow}></code> — [=permissions/Permissions policy=] to be applied to the <{fencedframe}>'s contents</dd>
 <dt>[=Accessibility considerations=]:</dt>
 <dd><p class=XXX>TODO</p></dd>
 <dt>[=DOM interface=]:</dt>
 <dd>
<xmp class=idl>
[Exposed=Window]
interface HTMLFencedFrameElement : HTMLElement {
  [HTMLConstructor] constructor();

  [CEReactions] attribute FencedFrameConfig? config;
  [CEReactions] attribute DOMString width;
  [CEReactions] attribute DOMString height;
  [CEReactions] attribute DOMString allow;
};
</xmp>
</dd>
</dl>

The <{fencedframe}> element [=represents=] its [=fenced navigable container/fenced navigable=].

Each <{fencedframe}> has a <dfn for=fencedframe>config</dfn>, which is either a
{{FencedFrameConfig}} or null. It is initially null.

<div algorithm=insertion>
  When a <{fencedframe}> element |element| is [=node is inserted into a document|inserted into a
  document=] whose [=Document/browsing context=] is non-null, run these steps:

  1. Let |nested traversable| be the result of [=create a new nested traversable|creating a new
     nested traversable=] for |element|.

  1. Set |nested traversable|'s [=navigable/loading mode=] to "`fencedframe`".

  1. <span class=XXX>Parse the sandbox attributes, once it exists</span>

  1. [=Process the fencedframe attributes=] with |element| and [=initialInsertion=] set to true.
</div>

<div algorithm=process-the-fencedframe-attributes>
  To <dfn>process the <{fencedframe}> attributes</dfn> given a <{fencedframe}> element |element| and
  a boolean <dfn><var>initialInsertion</var></dfn>, run these steps:

  1. [=Assert=]: |element| is [=connected=].

  Issue: It's not necessary to call the <a
  href=https://html.spec.whatwg.org/multipage/browsing-the-web.html#url-and-history-update-steps>URL
  and history update steps</a> as we do during usual <a
  href=https://html.spec.whatwg.org/multipage/iframe-embed-object.html#the-iframe-element:url-and-history-update-steps>child
  navigable creation</a> or <a
  href=https://html.spec.whatwg.org/multipage/nav-history-apis.html#apis-for-creating-and-navigating-browsing-contexts-by-name:url-and-history-update-steps>top-level
  traversable creation</a>, but we still need a mechanism to initialize
  {{History}}.{{History/length}} in the new navigable. This is an existing issue in the HTML
  Standard: <a
  href=https://github.com/whatwg/html/issues/9030>https://github.com/whatwg/html/issues/9030</a>.

  1. If |element|'s [=fencedframe/config=] is null and |initialInsertion| is true, then return.

  1. Let |url| be the [=URL record=] <code>about:blank</code>.

  1. <a spec="HTML" lt="parse a URL">Parse</a> |element|'s [=fencedframe/config=]'s
     [=fencedframeconfig/config=]'s [=fenced frame config/mapped url=]'s [=mapped url/value=]
     relative to |element|'s [=Node/node document=]. If this is successful, then set [=url=] to the
     <a spec="HTML">resulting URL record</a>.

  1. [=Navigate=] |element|'s [=fenced navigable container/fenced navigable=] to |url| using
     |element|'s [=Node/node document=], with [=historyHandling=] set to "<a for="history handling
     behavior">`replace`</a>" , and [=referrerPolicy=] set to <a>"`no-referrer`"</a>.
     <span class="XXX">TODO: generate and store the config instance</span>

  <wpt>
    /fenced-frame/header-referrer.https.html
  </wpt>
</div>

<div algorithm=destroy>
  When a <{fencedframe}> element is [=removed from a document=], the user agent <p class=XXX>TODO:
  destroy the nested traversable</p>.
</div>

The <dfn attribute for=HTMLFencedFrameElement>config</dfn> IDL attribute getter steps are to return
[=this=]'s [=fencedframe/config=].

<div algorithm=config-setter>
  The {{HTMLFencedFrameElement/config}} IDL attribute setter steps are:

  1. <span class=XXX>TODO</span>
</div>

The <dfn element-attr for=fencedframe>allow</dfn> attribute, when specified, determines the [=fenced
container policy=] that will be used when the [=Document/permissions policy=] for a {{Document}} in
the <{fencedframe}>'s [=fenced navigable container/fenced navigable=] is initialized. Its value must
be a [=serialized permissions policy=]. [[!PERMISSIONS-POLICY]]

The IDL attribute <dfn attribute for=HTMLFencedFrameElement>allow</dfn> must [=reflect=] the
respective content attribute of the same name.

<h3 id=dimension-attributes>Dimension attributes</h3>

This section details monkeypatches to [[!HTML]]'s <a
href="https://html.spec.whatwg.org/multipage/embedded-content-other.html#dimension-attributes">Dimension
attributes</a> section. This section will be updated to include <{fencedframe}> in the list of
elements that the <code>[=width=]</code> and <code>[=height=]</code> dimension attributes apply to.

<h3 id=fenced-frame-config-map>Fenced frame config mapping</h3>

Each [=traversable navigable=] has a <dfn for="traversable navigable" export>fenced frame config
mapping</dfn>, which is a new [=fenced frame config mapping=].

Note: This mapping is consulted during [=navigate|navigation=], and written to by what we
colloquially refer to as *URN-generating APIs* or *config-generating APIs*, that generate both [=urn
uuids=] and [=fenced frame configs=] for use in navigating <{fencedframe}> and <{iframe}> elements.
See for example, the <a href=https://wicg.github.io/turtledove/>FLEDGE</a> and <a
href=https://wicg.github.io/shared-storage/>Shared Storage</a> specifications.

A <dfn>fenced frame config mapping</dfn> has three submappings:

<dl dfn-for="fenced frame config mapping">
  : <dfn>pending config mapping</dfn>
  :: a [=map=] whose [=map/keys=] are [=urn uuids=] and whose [=map/values=] are [=fenced frame
     configs=]

  : <dfn>finalized config mapping</dfn>
  :: a [=map=] whose [=map/keys=] are [=urn uuids=] and whose [=map/values=] are [=fenced frame
     configs=]

  : <dfn>nested config mapping</dfn>
  :: a [=map=] whose [=map/keys=] are [=urn uuids=] and whose [=map/values=] are [=fenced frame
     configs=]
</dl>

Each [=fenced frame config mapping=] has a <dfn for="fenced frame config mapping">maximum number of
configs</dfn>, which is implementation-defined. The [=fenced frame config mapping/maximum number of
configs=] may be a nonnegative number or infinity.

Note: It is important to specify the behavior of
[=fenced frame config mapping/maximum number of configs=] because its semantics can interact with
config-generating APIs in a privacy sensitive way.

At a high level, in order to store a [=fenced frame config=] in the
[=traversable navigable/fenced frame config mapping=], one must first store a pending config, and
then turn the pending config into a finalized config. Those procedures are as follows:

<div algorithm>
  To <dfn for="fenced frame config mapping" export>store a pending config</dfn> into a particular
  [=fenced frame config mapping=] given a [=fenced frame config=] |config|, run these steps:

  1. Let |pendingMapping| be the [=fenced frame config mapping/pending config mapping=] of the
     associated [=fenced frame config mapping=].

  1. If the [=map/size=] of the [=fenced frame config mapping/pending config mapping=] + the
     [=map/size=] of the [=fenced frame config mapping/finalized config mapping=] >= the [=fenced
     frame config mapping/maximum number of configs=], return failure.

  1. Let |urn| be a randomly generated [=urn uuid=].

  1. [=map/Set=] |pendingMapping|[|urn|] to |config|.
</div>

<div algorithm>
  To <dfn for="fenced frame config mapping" export>finalize a pending config</dfn> in a particular
  [=fenced frame config mapping=] given a [=urn uuid=] |urn|, run these steps:

  1. Let |pendingMapping| be the [=fenced frame config mapping/pending config mapping=] of the
     associated [=fenced frame config mapping=].

  1. Let |finalizedMapping| be the [=fenced frame config mapping/finalized config mapping=] of the
     associated [=fenced frame config mapping=].

  1. If |pendingMapping|[|urn|] does not [=map/exist=], return failure.

  1. Let |finalizedConfig| be |pendingMapping|[|urn|].

  1. [=map/Remove=] |pendingMapping|[|urn|].

  1. [=map/Set=] |finalizedMapping|[|urn|] be |finalizedConfig|.
</div>

<div algorithm>
  To <dfn for="fenced frame config mapping" export>store nested configs</dfn> into a particular
  [=fenced frame config mapping=] given a [=fenced frame config instance/nested configs=]
  |nestedConfigs|, run these steps:

  1. Let |nestedMapping| be the [=fenced frame config mapping/nested config mapping=] of the
     associated [=fenced frame config mapping=].

  1. If |nestedConfigs| is null, return.

  1. [=map/iterate|For each=] |urn| → |config| of |nestedConfigs|:

    1. [=map/Set=] |nestedMapping|[|urn|] to |config|.
</div>

<div algorithm>
  To <dfn for="fenced frame config mapping" export>find a config</dfn> in a particular [=fenced
  frame config mapping=] given a [=urn uuid=] |urn|, run these steps:

  1. Let |nestedMapping| be the [=fenced frame config mapping/nested config mapping=] of the
     associated [=fenced frame config mapping=].

  1. Let |pendingMapping| be the [=fenced frame config mapping/pending config mapping=] of the
     associated [=fenced frame config mapping=].

  1. Let |finalizedMapping| be the [=fenced frame config mapping/finalized config mapping=] of
     the associated [=fenced frame config mapping=].

  1. If |nestedMapping|[|urn|] [=map/exists=], return its value.

  1. If |pendingMapping|[|urn|] [=map/exists=], wait until it does not [=map/exist=].

  1. If |finalizedMapping|[|urn|] [=map/exists=], return its value.

  1. Return failure.
</div>

<h3 id=fenced-frame-config-section>Fenced frame configs</h3>

<h4 id=fenced-frame-config-intro>Introduction</h4>

*This section is non-normative.*

A key feature of the <{fencedframe}> element is that web platform APIs can configure the behavior
of the frame in a way that limits the ability of other execution contexts to modify or inspect this
configuration, for security or privacy reasons. For example, the
<a href=https://wicg.github.io/turtledove/>FLEDGE</a> API performs on-device ad auctions over
cross-site data, and it is important that the ad that wins the auction can be loaded into a frame,
without the API caller knowing *which ad* won the auction or being able to manipulate the
environment in which the ad loads.

We achieve this using the concept of a "[=fenced frame config=]". A [=fenced frame config=] is a
collection of fields that can be loaded into <{fencedframe}> elements and that specifies the
resulting environments. [=Fenced frame configs=] can only be constructed by web platform APIs, not
initialized or modified arbitrarily. Their fields also contain "[=visibilities=]", which dictate
whether the field should be "redacted" when inspected through the {{FencedFrameConfig}} interface.
Config-generating APIs (like <a href=https://wicg.github.io/turtledove/>FLEDGE</a> and <a
href=https://wicg.github.io/shared-storage/>Shared Storage</a>) must specify values for all fields
of their fenced frame configs in order to ensure that they have considered the privacy implications
of each field, though they may choose to set the values to null.

Each time a <{fencedframe}> navigates to a [=fenced frame config=], it is instantiated as a new
[=fenced frame config instance=], which governs that particular context inside the [=fenced
navigable container/fenced navigable=].

<h4 id=fenced-frame-config-struct>The [=fenced frame config=] [=struct=]</h4>

We now establish some preliminary types:

A <dfn export for=fencedframeconfig>visibility</dfn> is either "<dfn export for=visibility>
`opaque`</dfn>" or "<dfn export for=visibility>`transparent`</dfn>".

A <dfn export for=fencedframetype>size</dfn> is a struct with non-negative integer <dfn export for=
"size">width</dfn> and non-negative integer <dfn export for="size">height</dfn>. <span class=XXX>
TODO: Maybe change the numeric type.</span>

An <dfn export for=fencedframetype>interest group descriptor</dfn> is a struct with <dfn export
for="interest group descriptor">owner</dfn>, which is a string, and <dfn export for="interest group
descriptor">name</dfn>, which is a string.

An <dfn export for=fencedframetype>exhaustive set of sandbox flags</dfn> is a [=sandboxing flag
set=].

An <dfn export for=fencedframetype>exhaustive set of permissions</dfn> is a [=list=] of
[=policy-controlled features=].

A <dfn export for=fencedframetype>fenced frame reporter</dfn> is <span class=XXX>TODO: Specify the type for this.</span>

<div algorithm>
  In order to <dfn export>report an event</dfn>, run these steps:

  1. <span class=XXX>TODO: fill this in</span>
</div>

<div algorithm>
  In order to <dfn export>report a private aggregation event</dfn>, run these steps:

  1. <span class=XXX>TODO: Fill this in</span>
</div>

<div algorithm>
  In order to <dfn export>set automatic beacon data</dfn>, run these steps:

  1. <span class=XXX>TODO: Fill this in</span>
</div>

An <dfn export for=fencedframetype>exfiltration budget metadata</dfn> is a struct containing an
<dfn export for="exfiltration budget metadata">origin</dfn>, which is an [=origin=]; and an <dfn
export for="exfiltration budget metadata">amount to debit</dfn>, which is a non-negative valid
floating point number.

An <dfn export for=fencedframetype>exfiltration budget metadata reference</dfn> is a struct
containing an <dfn export for="exfiltration budget metadata reference">origin</dfn>, which is an
[=origin=]; and an <dfn export for="exfiltration budget metadata reference">amount to debit
reference</dfn>, which is a mutable reference to a non-negative valid floating point number.
<span class=XXX>TODO: are mutable references a thing in spec?</span>

An <dfn export for=fencedframetype>embedder shared storage context</dfn> is a string.

A <dfn export>partition nonce</dfn> is an [=implementation-defined=] value.

Note: This is similar to the <a href=https://fetch.spec.whatwg.org/#network-partition-key>network
partition key</a> used by <a href=https://fetch.spec.whatwg.org/>Fetch</a>.

A <dfn export>fenced frame config</dfn> is a struct with the following [=struct/items=]:

<dl export dfn-for="fenced frame config">
  : <dfn>mapped url</dfn>
  :: a struct with the following fields:
    : <dfn for="mapped url">value</dfn>
    :: a [=URL=]

    : <dfn for="mapped url">visibility</dfn>
    :: a [=visibility=]

  : <dfn>container size</dfn>
  :: null, or a [=fencedframetype/size=]

  : <dfn>content size</dfn>
  :: null, or a struct with the following fields:
    : <dfn for="content size">value</dfn>
    :: a [=fencedframetype/size=]

    : <dfn for="content size">visibility</dfn>
    :: a [=visibility=]

  : <dfn>interest group descriptor</dfn>
  :: null, or a struct with the following fields:
    : <dfn for="interest group descriptor">value</dfn>
    :: an [=fencedframetype/interest group descriptor=]

    : <dfn for="interest group descriptor">visibility</dfn>
    :: a [=visibility=]

  : <dfn>effective sandbox flags</dfn>
  :: null, or a struct with the following fields:
    : <dfn for="effective sandbox flags">value</dfn>
    :: an [=fencedframetype/exhaustive set of sandbox flags=]

    : <dfn for="effective sandbox flags">visibility</dfn>
    :: a [=visibility=]

  : <dfn>effective permissions</dfn>
  :: null, or a struct with the following fields:
    : <dfn for="effective permissions">value</dfn>
    :: an [=fencedframetype/exhaustive set of permissions=]

    : <dfn for="effective permissions">visibility</dfn>
    :: a [=visibility=]

  : <dfn>fenced frame reporter</dfn>
  :: null, or a struct with the following fields:
    : <dfn for="fenced frame reporter">value</dfn>
    :: a [=fencedframetype/fenced frame reporter=]

    : <dfn for="fenced frame reporter">visibility</dfn>
    :: a [=visibility=]

  : <dfn>exfiltration budget metadata</dfn>
  :: null, or a struct with the following fields:
    : <dfn for="exfiltration budget metadata">value</dfn>
    :: an [=fencedframetype/exfiltration budget metadata=]

    : <dfn for="exfiltration budget metadata">visibility</dfn>
    :: a [=visibility=]

  : <dfn>nested configs</dfn>
  :: null, or a struct with the following fields:
    : <dfn for="nested configs">value</dfn>
    :: a [=list=] of [=fenced frame configs=]

    : <dfn for="nested configs">visibility</dfn>
    :: a [=visibility=]

  : <dfn>embedder shared storage context</dfn>
  :: null, or an [=fencedframetype/embedder shared storage context=]

  : <dfn>required permissions to load</dfn>
  :: a [=list=] of [=policy-controlled features=]
</dl>

<h4 id=fenced-frame-config-instance-struct>The [=fenced frame config instance=] [=struct=]</h4>

A <dfn export>fenced frame config instance</dfn> is a struct with the following [=struct/items=]:

<dl export dfn-for="fenced frame config instance">
  : <dfn>mapped url</dfn>
  :: a [=URL=]

  : <dfn>container size</dfn>
  :: null, or a [=fencedframetype/size=]

  : <dfn>content size</dfn>
  :: null, or a [=fencedframetype/size=]

  : <dfn>interest group descriptor</dfn>
  :: null, or an [=fencedframetype/interest group descriptor=]

  : <dfn>effective sandbox flags</dfn>
  :: null, or an [=fencedframetype/exhaustive set of sandbox flags=]

  : <dfn>effective permissions</dfn>
  :: null, or an [=fencedframetype/exhaustive set of permissions=]

  : <dfn>fenced frame reporter</dfn> TODO: including automatic beacon info
  :: null, or a [=fencedframetype/fenced frame reporter=]

  : <dfn>exfiltration budget metadata reference</dfn>
  :: null, or an [=fencedframetype/exfiltration budget metadata reference=]

  : <dfn>nested configs</dfn>
  :: null, or an [=ordered map=] whose [=map/keys=] are [=urn uuids=] and whose [=map/values=] are
     [=fenced frame configs=]

  : <dfn>partition nonce</dfn>
  :: a [=partition nonce=]

  : <dfn>embedder shared storage context</dfn>
  :: null, or an [=fencedframetype/embedder shared storage context=]

  : <dfn>required permissions to load</dfn>
  :: a [=list=] of [=policy-controlled features=]
</dl>

<div algorithm>
  To <dfn export>instantiate a config</dfn> given a [=fenced frame config=] |config|, return a
  [=fenced frame config instance=] with the following members:

    : [=fenced frame config instance/mapped url=]
    :: |config|'s [=fenced frame config/mapped url=]'s [=mapped url/value=]

    : [=fenced frame config instance/container size=]
    :: |config|'s [=fenced frame config/container size=] if null

    : [=fenced frame config instance/content size=]
    :: |config|'s [=fenced frame config/content size=] if null, otherwise |config|'s [=fenced frame
       config/content size=]'s [=content size/value=]

    : [=fenced frame config instance/interest group descriptor=]
    :: |config|'s [=fenced frame config/interest group descriptor=] if null, otherwise |config|'s
       [=fenced frame config/interest group descriptor=]'s [=interest group descriptor/value=]

    : [=fenced frame config instance/effective sandbox flags=]
    :: |config|'s [=fenced frame config/effective sandbox flags=] if null, otherwise |config|'s
       [=fenced frame config/effective sandbox flags=]'s [=effective sandbox flags/value=]

    : [=fenced frame config instance/effective permissions=]
    :: |config|'s [=fenced frame config/effective permissions=] if null, otherwise |config|'s
       [=fenced frame config/effective permissions=]'s [=effective permissions/value=]

    : [=fenced frame config instance/fenced frame reporter=]
    :: |config|'s <span class=XXX>TODO: Fill this in</span>

    : [=fenced frame config instance/exfiltration budget metadata reference=]
    ::
        1. If |config|'s [=fenced frame config/exfiltration budget metadata=] is null, set to null.

        1. Otherwise, set to a [=fencedframetype/exfiltration budget metadata reference=]:
            : [=exfiltration budget metadata reference/origin=]
            :: |config|'s [=fenced frame config/exfiltration budget metadata=]'s [=exfiltration
               budget metadata/value=]'s [=exfiltration budget metadata/origin=]

            : [=exfiltration budget metadata reference/amount to debit reference=]
            :: a reference to |config|'s [=fenced frame config/exfiltration budget metadata=]'s
               [=exfiltration budget metadata/value=]'s [=exfiltration budget metadata/amount to
               debit=]

    : [=fenced frame config instance/nested configs=]
    ::
        1. If |config|'s [=fenced frame config/nested configs=] is null, set to null.

        1. Otherwise:

           1. Let |results| be an empty [=ordered map=].

           1. [=list/For each=] |nested config| of |config|'s [=fenced frame config/nested
             configs=]'s [=nested configs/value=]:

               1. Let |urn| be a random, unique [=urn uuid=].

               1. [=map/Set=] |results|[|urn|] to |nested config|.

           1. Set [=fenced frame config instance/nested configs=] to |results|.

    : [=fenced frame config instance/partition nonce=]
    :: a random, unique [=partition nonce=]

    : [=fenced frame config instance/embedder shared storage context=]
    :: |config|'s [=fenced frame config/embedder shared storage context=]

    : [=fenced frame config instance/required permissions to load=]
    :: |config|'s [=fenced frame config/required permissions to load=]
</div>

Each [=navigable=] has a <dfn for=navigable>fenced frame config instance</dfn>, which is a [=fenced
frame config instance=] or null, initially null.

Advisement: This [=navigable/fenced frame config instance=] should really exist on [=traversable
navigable=], specifically a [=fenced navigable container/fenced navigable=], however until
third-party cookies are <a
href=https://w3ctag.github.io/web-without-3p-cookies/#introduction>deprecated</a>, this
specification supports many of the <{fencedframe}> constructs on the <{iframe}> element. This
requires that for the short term, a normal [=navigable container/content navigable=] be able to load
a [=fenced frame config=], and therefore have access to the navigation's corresponding [=fenced
frame config instance=].

<h4 id=fenced-frame-config-interface>The {{FencedFrameConfig}} interface</h4>

One major input to the <{fencedframe}> element is the {{FencedFrameConfig}} interface, which
maps to an internal [=fenced frame config=] [=struct=].

<pre class=idl>
  enum OpaqueProperty {"opaque"};

  typedef (unsigned long or OpaqueProperty) FencedFrameConfigSize;
  typedef USVString FencedFrameConfigURL;

  [Exposed=Window]
  interface FencedFrameConfig {
    readonly attribute FencedFrameConfigURL? url;
    readonly attribute FencedFrameConfigSize? containerWidth;
    readonly attribute FencedFrameConfigSize? containerHeight;
    readonly attribute FencedFrameConfigSize? contentWidth;
    readonly attribute FencedFrameConfigSize? contentHeight;

    undefined setSharedStorageContext(DOMString contextString);
  };
</pre>

Each {{FencedFrameConfig}} has two internal members: <dfn for=fencedframeconfig>urn</dfn>, which is a
[=urn uuid=], and <dfn for=fencedframeconfig>config</dfn>, which is a [=fenced frame config=].

<div algorithm="url getter">
  The {{FencedFrameConfig/url}} IDL attribute getter steps are:

  1. If {{FencedFrameConfig}}'s [=fencedframeconfig/config=]'s [=fenced frame config/mapped url=]'s
     [=mapped url/visibility=] is [=visibility/transparent=], return the [=fenced frame config/
     mapped url=]'s [=mapped url/value=].

  1. Otherwise, return `"opaque"`.
</div>

<div algorithm="containerWidth getter">
  The {{FencedFrameConfig/containerWidth}} IDL attribute getter steps are:

  1. If [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/container size=] is null,
     return null.

  1. Return [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/container size=]'s
     [=size/width=].
</div>

<div algorithm="containerHeight getter">
  The {{FencedFrameConfig/containerHeight}} IDL attribute getter steps are:

  1. If [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/container size=] is null,
     return null.

  1. Return [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/container size=]'s
     [=size/height=].
</div>

<div algorithm="contentWidth getter">
  The {{FencedFrameConfig/contentWidth}} IDL attribute getter steps are:

  1. If [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/content size=] is null,
     return null.

  1. If [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/content size=]'s [=content
     size/visibility=] is [=visibility/transparent=], return the [=fenced frame config/content
     size=]'s [=content size/value=]'s [=size/width=].

  1. Otherwise, return `"opaque"`.
</div>

<div algorithm="contentHeight getter">
  The {{FencedFrameConfig/contentHeight}} IDL attribute getter steps are:

  1. If [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/content size=] is null,
     return null.

  1. If [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/content size=]'s [=content
     size/visibility=] is [=visibility/transparent=], return the [=fenced frame config/content
     size=]'s [=content size/value=]'s [=size/height=].

  1. Otherwise, return `"opaque"`.
</div>

<div algorithm>
  The <dfn method for=FencedFrameConfig>setSharedStorageContext(|contextString|)</dfn> method steps
  are:

  1. Set [=this=]'s [=fencedframeconfig/config=]'s [=fenced frame config/embedder shared storage
     context=] to |contextString|.
</div>

<h3 id=fence-interface>The {{Fence}} interface</h3>

Several APIs specific to fenced frames are defined on the {{Fence}} interface.

<pre class=idl>
  enum FenceReportingDestination {
    "buyer",
    "seller",
    "component-seller",
    "direct-seller",
    "shared-storage-select-url",
  };

  dictionary FenceEvent {
    required DOMString eventType;
    required DOMString eventData;
    required sequence&lt;FenceReportingDestination&gt; destination;
  };

  typedef (FenceEvent or DOMString) ReportEventType;

  [Exposed=Window]
  interface Fence {
      undefined reportEvent(ReportEventType event);
      undefined setReportEventDataForAutomaticBeacons(FenceEvent event);
      sequence&lt;FencedFrameConfig&gt; getNestedConfigs();
  };
</pre>

<div algorithm>
  The <dfn method for=Fence>reportEvent(|event|)</dfn> method steps are:

  1. Let |instance| be [=this=]'s [=relevant global object=]'s [=associated Document=]'s [=node
     navigable=]'s [=navigable/traversable navigable=]'s [=navigable/fenced frame config instance=].

  1. If |instance| is null, then return.

  1. If the [=relevant settings object=]'s [=origin=] and |instance|'s
     [=fenced frame config instance/mapped url=]'s [=url/origin=] are not [=same origin=], then
     return.

  1. If |instance|'s [=fenced frame config instance/fenced frame reporter=] is null, then return.

  1. If |event| is a {{DOMString}}, run [=report a private aggregation event=] with |event| and
     |instance|'s [=fenced frame config instance/fenced frame reporter=].

  1. If |event| is a {{FenceEvent}}, run [=report an event=] with |event| and |instance|'s
     [=fenced frame config instance/fenced frame reporter=].

  <wpt>
    /fenced-frame/fence-report-event.https.html
  </wpt>
</div>

<div algorithm>
  The <dfn method for=Fence>setReportEventDataForAutomaticBeacons(|event|)</dfn>
  method steps are:

  1. Let |instance| be [=this=]'s [=relevant global object=]'s [=associated Document=]'s [=node
     navigable=]'s [=navigable/traversable navigable=]'s [=navigable/fenced frame config instance=].

  1. If |instance| is null, then return.

  1. If the [=relevant settings object=]'s [=origin=] and |instance|'s
     [=fenced frame config instance/mapped url=]'s [=url/origin=] are not [=same origin=], then
     return.

  1. If |instance|'s [=fenced frame config instance/fenced frame reporter=] is null, then return.

  1. Run [=set automatic beacon data=] with |event| and |instance|'s
     [=fenced frame config instance/fenced frame reporter=].

  <wpt>
    /fenced-frame/set-automatic-beacon.https.html
  </wpt>
</div>

<div algorithm>
  The <dfn method for=Fence>getNestedConfigs()</dfn> method steps are:

  1. Let |instance| be [=this=]'s [=relevant global object=]'s [=associated Document=]'s [=node
     navigable=]'s [=navigable/traversable navigable=]'s [=navigable/fenced frame config instance=].

  1. If |instance| is null, then return.

  1. If the [=relevant settings object=]'s [=origin=] and |instance|'s
     [=fenced frame config instance/mapped url=]'s [=url/origin=] are not [=same origin=], then
     return.

  1. If |instance|'s [=fenced frame config instance/nested configs=] is null, then return.

  1. Let |results| be an empty [=list=] of {{FencedFrameConfig}}s.

  1. [=map/For each=] |urn| → |config| of |instance|'s [=fenced frame config instance/nested
     configs=]:

     1. Let |newConfig| be a [=new=] {{FencedFrameConfig}} object created in [=this=]'s [=relevant
        realm=], with the following:

        : [=fencedframeconfig/urn=]
        :: |urn|

        : [=fencedframeconfig/config=]
        :: |config|

     1. [=list/Append=] |newConfig| to |results|.

  1. Return |results|.

  <wpt>
    /fenced-frame/get-nested-configs.https.html
  </wpt>
</div>

<h3 id=new-request-destination>New [=request=] [=request/destination=]</h3>

Every distinct element should have its own request destination to allow for special handling when
making requests (fenced frame request behavior deviates from iframe behavior in enough ways to
justify having a separate destination). Update the associated request [=request/destination=] list
to include a new entry, "<code>fencedframe</code>". It will have the [=request/initiator=] "", the
CSP directive <code>fenced-frame-src</code>, and the features HTML's
<code>&lt;fencedframe&gt;</code>.

Add "<code>fencedframe</code>" to the [=non-subresource request=] list and to the [=navigation
request=] list.

Add "<code>fencedframe</code>" to the {{RequestDestination}} enum.

In the [=fetch=] algorithm, step 13.2, where it says:

> A user agent should set value to the first matching statement, if any, switching on request’s
[=request/destination=]:

Add "<code>fencedframe</code>" to the switch cases alongside "<code>document</code>",
"<code>frame</code>", and "<code>iframe</code>".

<wpt>
  /fenced-frame/header-secFetchDest.https.html
</wpt>

<h2 id=html-integration>HTML Integration</h2>

<h3 id=window-extension>Extensions to the {{Window}} interface</h3>

<pre class="idl">
  partial interface Window {
    // Collection of fenced frame APIs
    readonly attribute Fence? fence;
  };
</pre>

Each {{Window}} object has an associated <dfn for=Window>fence</dfn>, which is a {{Fence}} instance created alongside the {{Window}}.

<div algorithm>
  The <dfn attribute for=Window>fence</dfn> getter steps are:
    1. If [=this=]'s [=Window/navigable=]'s [=navigable/fenced frame config instance=] is not null,
       then return [=this=]'s [=Window/fence=].

    1. Return null.

  <wpt>
    /fenced-frame/fence-api.https.html
  </wpt>
</div>

<h3 id=creating-browsing-contexts-patch>Modifications to creating browsing contexts</h3>

<div algorithm="creating a new browsing context and document patch">
  In [[HTML]]'s [=creating a new browsing context and document=] algorithm, rewrite the two steps
  starting with;

  1. If |creator| is non-null, then:

  to instead use the tighter condition:

  1. If |creator| is non-null and <var ignore>embedder</var> is not a <{fencedframe}> element, then:
</div>

Note: This is because we need to ensure that we do not leak <var ignore>creator</var>'s [=the
document's referrer|referrer=], [=Document/origin=], [=creator base url=], [=Document/policy
container=], across the fenced frame boundary.

<h3 id=nested-traversables>Nested traversables</h3>

<h4 id=nested-traversables-intro>Introduction</h4>

*This section is non-normative.*

The [[HTML]] Standard organizes [=navigables=] into two categories: [=child navigables=] and
[=traversable navigables=] (also known as [=top-level traversables=]). The introduction of features
like fenced frames, and to a lesser extent <a href=https://github.com/wicg/portals>portals</a>,
complicates this model by adding a new type of [=traversable navigable=] that is *sometimes* like a
[=child navigable=]. Because these new frame types are housed in a separate [=browsing context
group=] from their embedder, some concrete level of isolation is expected and required; on the other
hand since they are composed visually inside of *other* [=browsing context groups=], sometimes they
need to behave like the normal [=child navigables=] that we see in e.g., <{iframe}>s.

The complexity here is in deciding when terms like [=navigable container=],
[=navigable/parent|navigable parent=], and [=Document/descendant navigables=] need to cross the
[=traversable navigable=]/[=browsing context group=] boundary, versus when doing so would be unsafe
or incorrect. The examples below illustrate this point.

<p class=example id=fenced-user-activation>When a user [=user activation|activates=] content inside
of a {{Document}}, ordinarily the [=activation notification=] steps give user activation to all
[=Document/ancestor navigables=] and all [=same origin=] [=Document/descendant navigables=]. But
because a <{fencedframe}> can host sensitive content that needs to be isolated from its embedder,
and because [=user activation=] and [=consume user activation|consumption=] offer a communication
vector between these two parties, for the purpose of user activation a <{fencedframe}>'s
[=fenced navigable container/fenced navigable=] cannot not be considered a descendant of its
embedder, nor can its embedder be considered an ancestor of the <{fencedframe}>'s [=fenced navigable
container/fenced navigable=], in the way that the [=user activation=] algorithms currently use those
terms. In other words, we consider user activation to be "fenced" to denote that it never crosses the
[=fenced navigable container/fenced navigable=] boundary.</p>

<wpt>
  /fenced-frame/consume-user-activation.https.html
</wpt>

<p class=example id=unfenced-sandbox-inheritance>On the other hand, when a <{fencedframe}>'s
[=fenced navigable container/fenced navigable=] gets [=created a new nested traversable|created=] or
[=navigated=], it <span class=allow-2119>must</span> <a
href=https://html.spec.whatwg.org/#sandboxing:active-sandboxing-flag-set-3>inherit</a> its embedder
{{Document}}'s [=Document/active sandboxing flag set=] as is standard for {{Document}}s in normal
[=child navigables=]. If we did not do this, then the <{fencedframe}> element would be a trivial
sandbox bypass.</p>

To provide the isolation mentioned above, and its conditional relaxation, this specification defines
a new kind of "*parent*" for [=traversable navigables=] called an [=traversable navigable/unfenced
parent=], which provides a link to its embedder that algorithms can intentionally use when they need
to be "*unfenced*", as described above.

Note: Introducing a new kind of parent ([=traversable navigable/unfenced parent=]) is an intentional
design decision. It means that by default, the <{fencedframe}> boundary is private and isolated,
since by default nothing in the web platform traverses from a <{fencedframe}>'s [=fenced navigable
container/fenced navigable=] to its embedder. Care <span class=allow-2119>must</span> be taken when
modifying algorithms to make them capable of traversing across the <{fencedframe}> [=fenced navigable
container/fenced navigable=] boundary, and each modification of this sort will be evaluated
independently and appear in this specification.

The rest of this section provides patches to various [[HTML]] definitions (and their uses) that deal
with collections of related navigables, with the intention of fencing and unfencing various parts of
the web platform appropriately.

<h4 id=traversable-navigables>Traversable navigables</h4>

In [[HTML]]'s <a
href=https://html.spec.whatwg.org/multipage/document-sequences.html#traversable-navigable>Traversable
navigables</a> section, add the following:

In addition to the properties of a [=navigable=], a [=traversable navigable=] has:

 * An <dfn for="traversable navigable">unfenced parent</dfn>, a [=navigable=] or null, initially null.

Note: The [=traversable navigable/unfenced parent=] link is what gives a <{fencedframe}>'s
[=fenced navigable container/fenced navigable=] a link to its embedder, which is used carefully for
things that need to be "*unfenced*", like some algorithms in the focus processing model.

<div algorithm>
  To get a [=navigable=] |navigable|'s <dfn for=navigable>unfenced parent</dfn>:

    1. If |navigable| is a [=child navigable=], return |navigable|'s [=navigable/parent=].

    1. [=Assert=]: |navigable| is a [=fenced navigable container/fenced navigable=].

    1. Return |navigable|'s [=traversable navigable/unfenced parent=].

    Note: This algorithm is different from the [=traversable navigable=]'s [=traversable
    navigable/unfenced parent=] getter in that this algorithm first tries to get the [=navigable=]'s
    *normal* [=navigable/parent=] if |navigable| is a normal [=child navigable=].
</div>

<div algorithm>
  To get a [=navigable=] |navigable|'s <dfn for=navigable>unfenced container document</dfn>:

    1. Let |parentNavigable| be |navigable|'s [=navigable/unfenced parent=].

    1. Return |parentNavigable|'s [=navigable/active document=].
</div>

<h4 id=nested-traversables-inner>Nested traversables</h4>

In [[HTML]]'s <a
href=https://html.spec.whatwg.org/multipage/document-sequences.html#navigables>Navigables</a>
section, add a new subsection titled "Nested traversables" with the following text, definitions, and
algorithms.

Similar to [=navigable containers=] and their respective [=navigable container/content navigables=],
other elements (so far, only the <{fencedframe}> element) present a more isolated [=navigable=] to
the user. These elements are called <dfn>fenced navigable containers</dfn>.

A [=fenced navigable container=] has a <dfn for="fenced navigable container">fenced navigable</dfn>,
which is either a [=traversable navigable=] with a non-null [=traversable navigable/unfenced
parent=], or null. It is initially null.

<wpt>
  /fenced-frame/window-frameElement.https.html
</wpt>

<div algorithm>
  To <dfn>initialize the nested traversable</dfn> |traversable| given a [=document state=]
  |documentState| and a [=navigable=] |parent|:

  1. [=Initialize the navigable=] |traversable| given |documentState| and null.

  1. Set |traversable|'s [=traversable navigable/unfenced parent=] to |parent|.
</div>

<div algorithm>
  To <dfn>create a new nested traversable</dfn> given an element |element|:

  1. Let |group| be a new [=browsing context group=].

  Note: There doesn't seem to be a reason to [=set/append=] |group| to the user agent's [=browsing
  context group set=] like [=create a new browsing context group and document=] does.

  1. Let |document| be the second return value of [=creating a new browsing context and document=]
     given |element| [=Node/node document=], |element|, and |group|.

  1. Let |documentState| be a new [=document state=], whose [=document state/document=] is |document|.

  1. Let |traversable| be a new [=traversable navigable=].

  1. Let |parentNavigable| be |element|'s [=node navigable=].

  1. [=Initialize the nested traversable=] |traversable| given |documentState| and
     |parentNavigable|.

  1. Set |element|'s [=fenced navigable container/fenced navigable=] to |traversable|.

  1. Let |initialHistoryEntry| be |traversable|'s [=navigable/active session history entry=].

  1. Set |initialHistoryEntry|'s step to 0.

  1. [=Append=] |initialHistoryEntry| to |traversable|'s [=traversable navigable/session history
     entries=].

  1. Return |traversable|.
</div>

Note: The [=create a new nested traversable=] algorithm creates the first kind of [=traversable
navigable=] that is not a [=top-level traversable=]. This will require removing the note about
nested traversables in [[HTML]]'s <a
href=https://html.spec.whatwg.org/multipage/document-sequences.html#top-level-traversables>Top-level
traversables</a> section.

<h4 id=top-level-traversables>Top-level traversables</h4>

The [[HTML]] Standard currently defines a [=top-level traversable=] as a [=traversable navigable=]
whose [=navigable/parent=] is null, however this is an insufficient definition that this
specification changes. [[HTML]] mentions that outside of this specification, all [=traversable
navigables=] are [=top-level traversables=], but "envisions" future specifications that may want to
create a kind of [=traversable navigable|traversable=] that is nested, and achieves the nesting
through a non-null [=navigable/parent=]; hence the distinction between [=top-level traversables=]
and [=traversable navigables=] relies on the [=navigable/parent=] null-ness.

The [=fenced navigable container/fenced navigable=] this specification proposes is precisely what
[[HTML]] envisioned when carving out space for the distinction between [=top-level traversables=]
and [=traversable navigables=], however this specification does not make use of the
[=navigable/parent=] pointer for [=fenced navigable container/fenced navigables=], for reasons
described <a href=#nested-traversables-intro>above</a> (instead they use the [=traversable
navigable/unfenced parent=] pointer). That means by default, both [=top-level traversables=] and
[=fenced navigable container/fenced navigables=] both have null [=navigable/parents=], which renders
the distinction meaningless.

To mend the intended distinction between [=top-level traversables=] and [=fenced navigable container
/fenced navigables=], patch the following definitions like so:

<div algorithm>
  A <dfn>top-level traversable</dfn> is a [=traversable navigable=] whose [=navigable/parent=] and
  [=traversable navigable/unfenced parent=] are both null.
</div>

<br>

<div algorithm>
  To get the <dfn noexport for="navigable">top-level traversable</dfn> of a [=navigable=] |inputNavigable|:

    1. Let |navigable| be |inputNavigable|.

    1. [=iteration/While=]:

      1. If |navigable|'s [=navigable/parent=] and [=traversable navigable/unfenced parent=] are
         both null, then [=iteration/break=].

      1. Set |navigable| to |navigable|'s [=navigable/parent=] or [=traversable navigable/unfenced
         parent=], whichever is non-null.

         Note: Exactly one of |navigable|'s [=navigable/parent=] or [=traversable navigable/unfenced
         parent=] will be non-null here.

    1. Return |navigable|.
</div>

Note: With these new definitions, a [=top-level traversable=] is essentially "unfenced" as described
in the [[#nested-traversables-intro]].

<h3 id=navigable-traversing-algorithms>Modifications to navigable-traversing algorithms</h3>

<div algorithm="inclusive-descendant-navigables-patch">
  Modify the [=Document/inclusive descendant navigables=] algorithm to take a new optional
  [=boolean=] argument <dfn lt="inclusive-dn-unfenced">unfenced</dfn> that defaults to false.

  Further rewrite step 2 of this algorithm to:

  2. [=list/Extend=] <var ignore>navigables</var> with <var ignore>document</var>'s
     [=Document/descendant navigables=] with [=dn-unfenced|unfenced=] set to
     [=inclusive-dn-unfenced|unfenced=].
</div>

<div algorithm="descendant-navigables-patch">
  Modify the [=Document/descendant navigables=] algorithm to take a new optional [=boolean=]
  argument <dfn lt="dn-unfenced">unfenced</dfn> that defaults to false, and rewrite the algorithm
  like so:

  1. Let |navigables| be a new [=list=].

  1. Let |navigableContainers| be a [=list=] of all [=shadow-including descendants=] of <var
     ignore>document</var> that are [=navigable containers=] (or [=fenced navigable containers=], if
     [=dn-unfenced|unfenced=] us true), in [=shadow-including tree order=].

  1. [=list/For each=] |navigableContainer| of |navigableContainers|:

    1. If |navigableContainer|'s [=navigable container/content navigable=] and [=fenced navigable
       container/fenced navigable=] are both null, then [=iteration/continue=].

    1. Let |descendantNavigable| be either |navigableContainer|'s [=navigable container/content
       navigable=] or [=fenced navigable container/fenced navigable=], whichever is non-null.

    1. [=list/Extend=] |navigables| with |descendantNavigable|'s [=navigable/active document=]'s
       [=Document/inclusive descendant navigables=] with [=inclusive-dn-unfenced|unfenced=] set to
       [=dn-unfenced=].

  1. Return |navigables|.
</div>

<h3 id=focusing-changes>Modifications to the focusing algorithms</h3>

The [[HTML]] standard defines how to handle focusing elements and {{Window}}s, both by user gesture
and through script-initiated APIs. Since fenced frames are designed to prevent communication across
a fenced frame boundary, we need to handle focusing carefully. This is because when focus is pulled
across a fenced frame boundary, contexts on both sides of the boundary can detect that change, which
can be used to open a communication channel between a <{fencedframe}> and its embedder.

We do this is by not allowing the [=focusing steps=] to move script-initiated focus across a fenced
frame boundary.

<p class=example id=user-initiated-focus>When a user clicks on an element like a <{button}> inside a
<{fencedframe}> while another element *outside* of the <{fencedframe}> is [=focused=], because this
is a user-initiated action, the [=focusing steps=] will allow the <{button}> to [=gain focus=].
Without allowing that, no element inside of a <{fencedframe}> would never be able [=gain
focus=].</p>

<p class=example id=script-initiated-focus>If we were to continue blindly allowing all elements to
be [=focused=] via the {{HTMLOrSVGElement/focus()}} method as is the status quo before this
specification, a [=fenced navigable container=] and its [=fenced navigable container/fenced
navigable=] could use a sequence of {{HTMLOrSVGElement/focus()}} calls to send arbitrary data across
the fenced frame boundary, which is a privacy leak. To avoid this, we effectively "fence" the
{{HTMLOrSVGElement/focus()}} method, which sacrifices some functionality for privacy.</p>

<div algorithm=focusing-steps-patch>
  Modify the [=focusing steps=] to take a new optional [=boolean=] argument <dfn
  lt="focus-unfenced">unfenced</dfn> that defaults to false.

  Add a new step after step 3 of the algorithm (that changes new focus target) that reads:

  4. If |new focus target| is a [=fenced navigable container=] with non-null
    [=fenced navigable container/fenced navigable=], then set |new focus target| to the
    [=fenced navigable container/fenced navigable=]'s [=navigable/active document=].

  Add a new step after the step that defines the |new chain| variable, that reads:

  9. If [=focus-unfenced|unfenced=] is false, |new chain| [=list/contains=] a {{Document}}
    |document| whose [=node navigable=]'s [=navigable/traversable navigable=] is a
    [=fenced navigable container/fenced navigable=], and <var ignore>old chain</var> does not also
    [=list/contain=] |document|, then return.

    Note: This is how we bail-out early just before calling the [=focus update steps=], in the case
    where focus is trying to cross the fence.

  Modify the user agent sentence after the algorithm steps in [=focusing steps=] to read:

  User agents must [=immediately=] run the [=focusing steps=] for a [=focusable area=] or
  [=navigable=] |candidate| with [=focus-unfenced|unfenced=] set to true whenever the user attempts to
  move the focus to |candidate|.
</div>

<div algorithm=access-key-patch>
  Modify the action of the [=accesskey attribute command=] algorithm to be:

  1. Run the [=focusing steps=] for the element with [=focus-unfenced|unfenced=] set to true.

  1. <a>Fire a `click` event</a> at the element.
</div>

<div algorithm=activation-patch>
  Modify the behavior when a user [=activation|activates=] a [=click focusable=] [=focusable area=]
  to be:

  When a user [=activation|activates=] a [=click focusable=] [=focusable area=], the user agent must
  run the [=focusing steps=] on the [=focusable area=] with <var ignore>focus trigger</var> set
  to "`click`" and [=focus-unfenced|unfenced=] set to true.
</div>

<div algorithm=hide-popover-patch>
  Modify step 10 of the [=hide popover algorithm=] to read:

  10. If |previouslyFocusedElement| is not null, then:
      1. Set <var ignore>element</var>'s [=previously focused element=] to null.
      2. If <var ignore>focusPreviousElement</var> is true, then run the [=focusing steps=] for
        |previouslyFocusedElement| with [=focus-unfenced|unfenced=] set to true; the viewport
        should not be scrolled by doing this step.

  Note: Although dismissing a popover manually is a user-initiated gesture, the
  [=focusing steps=] will be called with [=focus-unfenced|unfenced=] set to false regardless
  of whether this was called from user gesture or via a script call.
</div>

<div algorithm=interactively-validate-patch>
  Modify the first bullet point of step 3 of the [=interactively validate the constraints=]
  algorithm to read:

  * User agents may focus one of those elements in the process, by running the
    [=focusing steps=] for that element, and may change the scrolling position of the
    document, or perform some other action that brings the element to the user's attention.
    If these steps were invoked by user gesture, [=focusing steps=] can be called with
    [=focus-unfenced|unfenced=] set to true. For elements that are
    [=form-associated custom elements=], user agents should use their [=face validation anchor=]
    instead, for the purposes of these actions.
</div>

<div algorithm=has-focus-steps>
  Add a step after step 2 of the while loop in the [=has focus steps=] algorithm that reads:

  3. If the [=focused area=] of |candidate| is a [=fenced navigable container=] with a non-null
    [=fenced navigable container/fenced navigable=], then set |candidate| to the [=navigable/active
    document=] of that [=fenced navigable container=]'s [=fenced navigable container/fenced
    navigable=].
</div>

<div algorithm=focus-chain>
  Modify step 3 of the while loop in the [=focus chain=] algorithm to read:
  3. If |currentObject| is a [=focusable area=], then set |currentObject| to |currentObject|'s [=DOM
     anchor=]'s [=Node/node document=].

     Otherwise, if |currentObject| is a {{Document}} whose [=node navigable=]'s [=navigable/parent=]
     is non-null, then set |currentObject| to |currentObject|'s [=node navigable=]'s
     [=navigable/parent=].

     Otherwise, if |currentObject| is a {{Document}} whose [=node navigable=] is a [=traversable
     navigable=] whose [=traversable navigable/unfenced parent=] is non-null, then set
     |currentObject| to |currentObject|'s [=node navigable=]'s [=traversable navigable/unfenced
     parent=].

     Otherwise, [=iteration/break=].
</div>
  
<div algorithm=get-the-focusable-area>
  Modify the [=get the focusable area=] algorithm. Add a new case to the switch statement:

  <dl class="switch">
    <dt>If <var ignore>focus target</var> is a [=fenced navigable container=] with a non-null [=fenced navigable container/fenced navigable=]</dt>

    <dd><p>Return the [=fenced navigable container=]'s [=fenced navigable container/fenced
    navigable=]'s [=navigable/active document=].</p></dd>
  </dl>

  Note: This algorithm can unconditionally "jump the fence" boundary because its return value always
  feeds into an algorithm that _does_ carefully consider the fence boundary.
</div>

<div algorithm=currently-focused-area-of-a-top-level-traversable>
  Modify step 3 of the [=currently focused area of a top-level traversable=] algorithm to read:

  3. While |candidate|'s [=focused area=] is either a [=navigable container=] with a non-null
    [=navigable container/content navigable=] or a [=fenced navigable container=] with a non-null
    [=fenced navigable container/fenced navigable=]: set |candidate| to the
    [=navigable/active document=] of either that [=navigable container=]'s
    [=navigable container/content navigable=] or that [=fenced navigable container=]'s
    [=fenced navigable container/fenced navigable=], whichever is non-null.
</div>

<div algorithm=sequential-focus-navigation-patch>
  Modify step 6 of the [=sequential focus navigation=] algorithm to read:

  6. If |candidate| is not null, then run the [=focusing steps=] for
    |candidate| with [=focus-unfenced|unfenced=] set to true and return.

  Modify step 9 of the [=sequential focus navigation=] algorithm to read:

  9. Otherwise, |starting point| is a [=focusable area=] in a [=child navigable=] or
    [=fenced navigable container/fenced navigable=]. Set |starting point| to that
    [=child navigable=] or [=fenced navigable container/fenced navigable=]'s
    [=traversable navigable/unfenced parent=] and return to the step labeled <i>loop</i>.
</div>

<div algorithm=sequential-navigation-search-patch>
  Modify step 2 of the [=sequential navigation search algorithm=] to read:

  2. If |candidate| is a [=navigable container=] with a non-null
    [=navigable container/content navigable=], then let |new candidate| be the result of running the
    [=sequential navigation search algorithm=] with |candidate|'s
    [=navigable container/content navigable=] as the first argument, <var ignore>direction</var> as
    the second, and <i>sequential</i> as the third.

    If |candidate| is a [=fenced navigable container=] with a non-null
    [=fenced navigable container/fenced navigable=], then let |new candidate| be the result of
    running the [=sequential navigation search algorithm=] with |candidate|'s
    [=fenced navigable container/fenced navigable=] as the first argument,
    <var ignore>direction</var> as the second, and <i>sequential</i> as the third.

    If |new candidate| is null, then let <var ignore>starting point</var>
    be |candidate|, and return to the top of this algorithm. Otherwise, let
    |candidate| be |new candidate|.
</div>

<wpt>
  /fenced-frame/anchor-focus.https.html
  /fenced-frame/autofocus-denied.https.html
  /fenced-frame/script-focus.https.html
</wpt>

<h3 id=navigation-patch>Navigation</h3>

This section describes how the <{fencedframe}> element interacts with the ever-complicated process
of navigation, which includes integration with various headers, isolation mechanisms, and policies.

<h4 id=supports-loading-mode>The \`<a http-header><code>Supports-Loading-Mode</code></a>\` HTTP response header</h4>

Add the new [=structured header/token=] below to the list of valid [=structured header/tokens=] for the \`<a
http-header><code>Supports-Loading-Mode</code></a>\` response header:

The \`<code><dfn export for="Supports-Loading-Mode">fenced-frame</dfn></code>\` token indicates that
the response can be used to create a {{Document}} inside of a [=fenced navigable container/fenced
navigable=]. Without this explicit opt-in, all navigations inside of a [=fenced navigable
container/fenced navigable=] will fail, as outlined in [[#navigation-patch]].

[[HTML]]'s [=attempt to populate the history entry's document=] algorithm is modified such that just
before the step inside the [=queue a task|queued task=] starting with "If <var ignore>failure</var>
is true, then:", insert a new step:

<div algorithm=navigation-patch>

1. Otherwise, if all of the following conditions are true:

    * |navigationParams|'s [=navigation params/navigable=]'s [=navigable/traversable navigable=] is
      a [=fenced navigable container/fenced navigable=];
    * |navigationParams|'s [=navigation params/response=]'s [=response/URL=]'s [=url/scheme=] is
      "<code>https</code>"; and
    * the result of [=getting the supported loading modes=] for |navigationParams|'s [=navigation
      params/response=] does not [=list/contain=] \`<code><a
      for="Supports-Loading-Mode">fenced-frame</a></code>\`

   then set <var ignore>failure</var> to true.

</div>

<h4 id=coop-coep>COOP, COEP, and cross-origin isolation</h4>

Outside of this specification, the \`<a http-header><code>Cross-Origin-Opener-Policy</code></a>\`
header only <a
href=https://html.spec.whatwg.org/C#populating-a-session-history-entry:top-level-traversable-2>applies</a>
to [=top-level traversables=] instead of all [=navigables=], and this specification continues this
intention insofar as this header does not have an impact on [=fenced navigable container/fenced
navigables=], nor is it inherited from its embedder. Consequently, the [=browsing context group=]
hosted inside of a [=fenced navigable container/fenced navigable|fenced traversable navigable=] will
always have its [=browsing context group/cross-origin isolation mode=] set to "<a for="cross-origin
isolation mode">`none`</a>".

Nevertheless, a [=fenced navigable container/fenced navigable=] respects its [=traversable
navigable/unfenced parent=]'s [=policy container/embedder policy=], which is accomplished below:

<div algorithm=coep-adherence-patch>
  In the [=check a navigation response's adherence to its embedder policy=] algorithm, rewrite all
  occurrences of:

    * |navigable|'s [=navigable/container document=]

  with:

    * |navigable|'s [=navigable/unfenced container document=]
</div>

Note: This causes navigations inside of a <{fencedframe}> to fail if they are not served with a
suitable \`<a http-header><code>Cross-Origin-Embedder-Policy</code></a>\` header, just as
<{iframe}>s behave.

Issue: Determine if we need to fence or unfence the [=queue a cross-origin embedder policy
inheritance violation=] algorithm, as leaving it unfenced may cause a privacy leak.

<div algorithm=corp-patch>
  Next, we modify how the [=cross-origin resource policy check=] <a
  href=https://html.spec.whatwg.org/C#populating-a-session-history-entry:cross-origin-resource-policy-check>applies
  to navigation requests</a>. Rewrite step 19, substep 13 of the [=create navigation params by
  fetching=] algorithm like so:

    1. If |response| is not a [=network error=], |navigable| is a [=child navigable=] or [=fenced
       navigable container/fenced navigable=], and the result of performing a [=cross-origin
       resource policy check=] with |navigable|'s [=navigable/unfenced container document=]'s
       [=Document/origin=], |navigable|'s [=navigable/unfenced container document=]'s [=relevant
       settings object=], <var ignore>request</var>'s [=request/destination=], |response|, and
       true is **blocked**, then set |response| to a [=network error=] and [=iteration/break=].

       Note: Here we're running the [=cross-origin resource policy check=] against the
       [=navigable/unfenced parent|unfenced parent navigable=] rather than |navigable| itself. This
       is because we care about the same-originness of the embedded content against the embedder's
       context (ignoring the "fence"), not the navigation source.
</div>

Issue: Determine if we need to fence or unfence the [=queue a cross-origin embedder policy
CORP violation report=] algorithm, as leaving it unfenced may cause a privacy leak.

<wpt>
  /fenced-frame/embedder-coop-coep-blocked.https.html
  /fenced-frame/embedder-no-coep.https.html
  /fenced-frame/embedder-require-corp.https.html
</wpt>

<h3 id=page-visibility>Page visibility</h3>

The <a href=https://html.spec.whatwg.org/#page-visibility>Page visibility</a> section of [[HTML]] is
modified such that the first step of the algorithm that runs when a user-agent changes a
[=traversable navigable=]'s [=system visibility state=] calls the [=Document/inclusive descendant
navigables=] algorithm with [=inclusive-dn-unfenced|unfenced=] set to true.

<h2 id="interaction-with-other-specs">Interactions with other specifications</h2>

Due to the necessarily cross-cutting nature of the <{fencedframe}> element and its interactions with
core concepts like [=navigable=] and [=browsing context group=], there are a number of
specifications that rely on terms whose usages must be re-evaluated in light of this specification;
this section houses the various changes that we propose to other specifications.

<h3 id=prerendering-monkeypatch>Prerendering</h3>

The <a href=https://wicg.github.io/nav-speculation/prerendering.html>Prerendering Revamped</a>
specification defines [=navigable=]'s [=navigable/loading mode=] and the values it can take on. Our
specification adds another value for fenced frames:

: "`fencedframe`"
:: This [=navigable=] is displaying a <{fencedframe}>'s content

Issue: Specify the behavior that leads to the following:

<wpt>
  /fenced-frame/prerender.https.html
</wpt>

<h3 id=csp-integration>Content Security Policy</h3>

<h4 id=csp-intro>Intro</h4>

*This section is non-normative*.

Content Security Policy [[!CSP]] can ordinarily be used by web content associated with a
{{Document}} that hosts a [=navigable container=] to limit the source of navigations in a [=child
navigable=].

In order to prevent [[!CSP]] from being used a communication side-channel exposing the [=URL=] of
navigations inside a <{fencedframe}> to the site operating its embedder, the only [=source
expressions=] that can influence a <{fencedframe}> navigation are:

 * The <a grammar>scheme-source</a> "`https:`"
 * The <a grammar>host-source</a> "`https://*:*`"
 * The [=string=] "`*`"

See our <a
href=https://github.com/WICG/fenced-frame/blob/master/explainer/interaction_with_content_security_policy.md#proposal---scheme-source-matching>CSP
explainer</a> that describes this.

<h4 id=csp-algorithms>Algorithms</h4>

<div algorithm=pre-request-check-csp>
  Add a step after step 2 of the [=frame-src pre-request check=] that says:

  3. If <var ignore>request</var>'s [=request/destination=] is "`fencedframe`", and this directive's
     [=directive value|value=] does not [=set/contain=] either "`https:`", "`https://*:*`", or
     "`*`", return "`Blocked`".
</div>

<div algorithm=post-request-check-csp>
  Add a step after step 2 of the [=frame-src post-request check=] that says:

  3. If <var ignore>request</var> [=request/destination=] is "`fencedframe`", and this directive's
    [=directive value|value=] does not contain either "`https:`", "`https://*:*`", or "`*`", return
    "`Blocked`".
</div>

Next, we modify the behavior of the CSPEE spec. If the embedding frame specifies a
[=required csp=], fenced frames will not load. This is done to prevent arbitrary data flow from the
embedder to the fenced frame.

<div algorithm=cspee-changes>
  Add a step after step 1 in the [=Is response to request blocked by context's required CSP?=]
  algorithm that reads:

  2. If <var ignore>context</var>'s [=required csp=] is not `null`, and <var ignore>request</var>
    [=request/destination=] is "`fencedframe`", return "`Blocked`".
</div>

<h4 id=new-csp-directive>New fenced-frame-src [[!CSP]] [=directive=]</h4>

Fenced frames are a different element from an iframe. Therefore, using the
<b><i>[=frame-src=]</i></b> directive wouldn't give web sites enough control over their CSP rules.
Introduce a new [[!CSP]] [=directive=]: <b><i>fenced-frame-src</i></b>. The monkey-patched
specification is printed below:

<div algorithm=fenced-frame-src>
  The <dfn>fenced-frame-src</dfn> directive restricts the URLs which may be loaded into a
  <{fencedframe}>'s [=fenced navigable container/fenced navigable=]. The syntax for the directive's
  name and value is described by the following ABNF:

  <pre>
    directive-name  = "fenced-frame-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  <div id="fenced-frame-src-example" class="example">
    Given a page with the following Content Security Policy:
    <pre>
      <a http-header>Content-Security-Policy</a>: <a>fenced-frame-src</a> https://example.com/
    </pre>

    Fetches for the following code will return a [=network error=], as the URL provided does not
    match `fenced-frame-src`'s <a>source list</a>:

    <pre highlight="html">
      &lt;fencedframe src="https://example.org/"&gt;
      &lt;/fencedframe&gt;
    </pre>
  </div>

  The <a href="https://w3c.github.io/webappsec-csp/#frame-src-pre-request">Pre-request check</a> and
  <a href="https://w3c.github.io/webappsec-csp/#frame-src-post-request">Post-request check</a> will
  be the same as the
  <a href="https://w3c.github.io/webappsec-csp/#directive-frame-src">frame-src</a>'s check.
</div>

<div algorithm=default-src-amendment>
  The [=default-src=] directive's Example 7 and Example 8 will be amended. Where it says:

  <pre>
    <a http-header>Content-Security-Policy</a>: <a>connect-src</a> <a grammar>'self'</a>;
                            ...
                            <a>worker-src</a> <a grammar>'self'</a>
  </pre>

  It will now say:

  <pre>
    <a http-header>Content-Security-Policy</a>: <a>connect-src</a> <a grammar>'self'</a>;
                            ...
                            <a>fenced-frame-src</a> <a grammar>'self'</a>;
                            ...
                            <a>worker-src</a> <a grammar>'self'</a>
  </pre>
</div>

<div algorithm=directive-fallback-list>
  In the <a href="https://w3c.github.io/webappsec-csp/#directive-fallback-list">directive fallback
  list</a>, in step 1, add a new entry to the list:

  : "`fenced-frame-src`"
  ::
    1.  Return `<< "fenced-frame-src", "frame-src", "child-src", "default-src" >>`.
</div>

<div algorithm=effective-directive-switch-patch>
  Modify the switch on step 3 of the [=Get the effective directive for request=] algorithm to
  include the following case:

  : "`fencedframe`"
  ::
    1.  Return `fenced-frame-src`.
</div>

<wpt>
  /fenced-frame/ancestor-throttle.https.html
  /fenced-frame/csp-allowed.https.html
  /fenced-frame/csp-blocked.https.html
  /fenced-frame/csp-fenced-frame-src-allowed.https.html
  /fenced-frame/csp-fenced-frame-src-blocked.https.html
  /fenced-frame/csp-frame-src-allowed.https.html
  /fenced-frame/csp-frame-src-blocked.https.html
  /fenced-frame/csp-transparent-url.https.html
  /fenced-frame/csp.https.html
  /fenced-frame/cspee.https.html
  /fenced-frame/embedder-csp-not-propagate.https.html
</wpt>

<h3 id=permissions-policy-changes>Permissions Policies</h3>

Permissions are granted to {{Document}} inside of <{fencedframe}>s through the
{{FencedFrameConfig}} object and its associated internal [=fencedframeconfig/config=], which defines
the permissions [=fenced frame config/required permissions to load|required=] for a <{fencedframe}>
to navigate successfully. Specifically, a {{Document}} inside of a <{fencedframe}> can only load if
it has opted into all of the [=fenced frame config/required permissions to load=].

<h4 id=fenced-container-policies>Fenced container policies</h4>

TODO: define <dfn>fenced container policy</dfn> here, which is current referenced by
<{fencedframe/allow}>.

<h4 id=permissions-policy-patches>Algorithm patches</h4>

<div algorithm=create-permissions-policy>
  Modify the definition of [=Create a Permissions Policy for a navigable=] to read:

  Given null or an element (|container|), an [=origin=] (<var ignore>origin</var>), and an optional
  [=list=] of [=policy-controlled features=] (|required features|), this algorithm returns a new
  [=Document/permissions policy=].

  Rewrite step 1 of the algorithm to read:

  1. [=Assert=]: if not null, |container| is either a [=navigable container=] or a [=fenced
     navigable container=].

  Add a new step after step 1 that reads:

  2. [=Assert=]: if |container| is not a [=fenced navigable container=], |required features| is not
     given.

  Rewrite step 4 to read:

  4. If |container| is a [=fenced navigable container=], then for each |feature| supported:

       1. If |feature| [=list/exists=] in |required features|, set |inherited policy|[|feature|] to
          "`Enabled`".

          Otherwise, set |inherited policy|[|feature|] to "`Disabled`".

     Otherwise, for each |feature| supported,

       1. Let |isInherited| be the result of running [=Define an inherited policy for feature in
          container at origin=] on |feature|, |container| and <var ignore>origin</var>.

       2. Set |inherited policy|[|feature|] to |isInherited|.
</div>

<div algorithm=allow-attribute-fenced-frame>
  Rename the <a href=https://w3c.github.io/webappsec-permissions-policy/#iframe-allow-attribute>The
  `allow` attribute of the `iframe` element</a> section to "The `allow` attribute of the `iframe`
  and `fencedframe` element", and rewrite the section to read:

  <{iframe}> and <{fencedframe}> elements have an respective `allow` attributes (<{iframe}>:
  <{iframe/allow}>; <{fencedframe}>: <{fencedframe/allow}>), which contain an [=ASCII-serialized
  policy directive=].

  The allowlist for the features named in the attribute may be empty; in that case, the default
  value for the allowlist is "`src`", which represents the origin of the URL in the iframe’s src
  attribute, or the fencedframe's [=fenced frame config=].

  When not empty, the <{iframe/allow}> attribute will result in adding an allowlist for each
  recognized feature to the iframe element’s content navigable's container policy or the fencedframe
  element's [=fenced navigable container/fenced navigable=]'s container policy, when it is
  constructed.
</div>

<div algorithm=create-permissions-policy-response>
  Modify the definition of [=Create a Permissions Policy for a navigable from response=] to read:

  Given null, a [=navigable container=], or a [=fenced navigable container=] (|container|), an
  [=origin=] (|origin|), a [=response=] (<var ignore>response</var>), and null or a
  [=list=] of [=features=] (|required features|), this algorithm returns a new
  [=Document/permissions policy=].

  Modify step 1 of the algorithm to read:
  1. Let <var ignore>policy</var> be the result of running
    [=Create a Permissions Policy for a navigable=] given |container|, |origin|, and
    |required features|.
</div>

<div algorithm=shared-document-creation-changes>
  Modify the [=create and initialize a Document object=] algorithm. Rewrite step 3 to read:

  3. Let <var ignore>permissionsPolicy</var> be the result of [=Create a Permissions Policy for a
    navigable from response|creating a permissions policy from a response=] given
    |navigationParams|'s [=navigable=]'s [=navigable container|container=], |navigationParams|'s
    [=navigation params/origin=], |navigationParams|'s [=navigation params/response=], and
    |navigationParams|'s [=navigable=]'s [=fenced frame config instance=]'s [=fenced frame config
    instance/required permissions to load=].
</div>

<div algorithm=new-browsing-context-changes>
  Modify the [=create a new browsing context and document=] algorithm. Rewrite step 7 to read:

  7. Let <var ignore>permissionsPolicy</var> be the result of [=Create a Permissions Policy for a
    navigable|creating a permissions policy=] given <var ignore>embedder</var>,
    <var ignore>origin</var>, and null.

  Note: This change is made in addition to the changes to [=create a new browsing context and
  document=] outlined in [[#creating-browsing-contexts-patch]].
</div>

<div algorithm=attempt-populate-history-patches>
  Modify [[HTML]]'s [=attempt to populate the history entry's document=] algorithm. Add a step
  before the step inside the [=queue a task|queued task=] starting with "If
  |failure| is true, then:" that reads:

  8. Otherwise, if the result of [=Should navigation response to navigation request be blocked by
    Permissions Policy?=] given |navigationParams|'s [=request=],
    |navigationParams|'s [=response=], and <var ignore>navigable</var> is "`Blocked`", then set
    |failure| to true.
</div>

<div algorithm=permissions-policy-block-request>
  Create a new algorithm in the [[!permissions-policy]] spec, called <dfn export>Should navigation
  response to navigation request be blocked by Permissions Policy?</dfn>.

  Given a [=response=] (|response|), a [=request=] (|request|), and a [=navigable=] (|navigable|),
  this algorithm returns `Blocked` or `Allowed`.

  1. If |navigable| is not a [=fenced navigable container/fenced navigable=], then return `Allowed`.

  2. Let |required permissions to load| be the |navigable|'s [=fenced frame config instance=]'s
    [=fenced frame config instance/required permissions to load=].

  3. Let |inherited policy| be |request|'s [=request/client=]'s
    [=environment/target browsing context=]'s [=browsing context/active document=]'s
    [=Document/permissions policy=]'s [=inherited policy=].

  4. Let |origin| be |response|'s [=response/url=]'s [=url/origin=].

  5. For each |permission| in |required permissions to load|:

    1. If |permission| does not exist in |inherited policy|, and |permission|'s
      [=default allowlist=] is not "`*`", return "`Blocked`".
      
    2. Otherwise, if the allowlist at |inherited policy|[|permission|] does not
      [=permissions/matches|match=] |origin|, return "`Blocked`".
  
  6. Return "`Allowed`."
</div>
